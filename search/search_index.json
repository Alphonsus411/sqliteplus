{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SQLitePlus Enhanced SQLitePlus Enhanced re\u00fane en un mismo paquete todo lo necesario para trabajar c\u00f3modamente con bases SQLite. Puedes montar una API moderna o limitarte a gestionar la base desde la consola, seg\u00fan lo que necesites en cada momento. Qu\u00e9 ofrece Operaciones asincr\u00f3nicas que cuidan el acceso concurrente a varias bases. Inicio de sesi\u00f3n con JWT usando un sencillo archivo JSON de usuarios. Compatibilidad con SQLCipher , sin complicaciones extra para quien no lo necesite. Copias y exportaciones guiadas para obtener CSVs o respaldos fechados con un comando. CLI sqliteplus con mensajes claros que acompa\u00f1an cada paso. Explora el men\u00fa lateral para seguir los pasos de instalaci\u00f3n, configuraci\u00f3n y ejemplos de uso paso a paso.","title":"SQLitePlus Enhanced"},{"location":"#sqliteplus-enhanced","text":"SQLitePlus Enhanced re\u00fane en un mismo paquete todo lo necesario para trabajar c\u00f3modamente con bases SQLite. Puedes montar una API moderna o limitarte a gestionar la base desde la consola, seg\u00fan lo que necesites en cada momento.","title":"SQLitePlus Enhanced"},{"location":"#que-ofrece","text":"Operaciones asincr\u00f3nicas que cuidan el acceso concurrente a varias bases. Inicio de sesi\u00f3n con JWT usando un sencillo archivo JSON de usuarios. Compatibilidad con SQLCipher , sin complicaciones extra para quien no lo necesite. Copias y exportaciones guiadas para obtener CSVs o respaldos fechados con un comando. CLI sqliteplus con mensajes claros que acompa\u00f1an cada paso. Explora el men\u00fa lateral para seguir los pasos de instalaci\u00f3n, configuraci\u00f3n y ejemplos de uso paso a paso.","title":"Qu\u00e9 ofrece"},{"location":"api/","text":"API REST - SQLitePlus Enhanced La API ofrece operaciones CRUD sobre m\u00faltiples bases SQLite protegidas por JWT. Swagger disponible en: http://localhost:8000/docs Autenticaci\u00f3n POST /token Genera un token JWT v\u00e1lido por una hora. Las credenciales se validan contra el archivo definido en SQLITEPLUS_USERS_FILE . Nota: la ruta se anuncia de forma relativa en el esquema OpenAPI, por lo que en despliegues con root_path o montajes aparecer\u00e1 como <prefijo>/token . Body (form-urlencoded) username password Respuestas 200 OK : { \"access_token\": \"<jwt>\", \"token_type\": \"bearer\" } 400 Bad Request : credenciales incorrectas o formulario inv\u00e1lido. 500 Internal Server Error : problemas al cargar el archivo de usuarios. Gesti\u00f3n de tablas POST /databases/{db_name}/create_table Crea una tabla si no existe. Los nombres de columnas se validan mediante CreateTableSchema y se escapan con comillas dobles. Normalizaci\u00f3n y validaciones de nombres Se eliminan espacios iniciales/finales de cada nombre antes de validar el patr\u00f3n de SQLite. La comparaci\u00f3n para detectar duplicados se hace con casefold() , por lo que \"Nombre\" y \" nombre \" se consideran el mismo identificador. Si despu\u00e9s de normalizar hay nombres repetidos, la API responde con 400 Bad Request . Query : table_name (puede incluir espacios o guiones; la API lo escapar\u00e1 autom\u00e1ticamente) Body : { \"columns\": { \"id\": \"INTEGER PRIMARY KEY\", \"msg\": \"TEXT\", \"created_at\": \"TEXT\" } } Errores comunes 400 : nombre de tabla inv\u00e1lido, columnas duplicadas o tipos vac\u00edos. 500 : error inesperado en la base. DELETE /databases/{db_name}/drop_table Elimina la tabla indicada. No falla si la tabla no existe. Query : table_name (obligatorio) curl -X DELETE \"http://127.0.0.1:8000/databases/demo/drop_table?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" Operaciones CRUD POST /databases/{db_name}/insert Inserta un registro en la tabla especificada. El payload puede llegar ya normalizado bajo la clave values o como un objeto plano (por compatibilidad con clientes sencillos); en este \u00faltimo caso, la API lo reestructura internamente a {\"values\": { ... }} antes de procesarlo. Query : table_name (obligatorio) Body (JSON) : { \"values\": { \"columna\": \"valor\", ... } } o { \"columna\": \"valor\", ... } curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{ \"values\": { \"msg\": \"Texto desde la API\" } }' curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"msg\": \"Texto\"}' 404 Not Found : la tabla indicada en table_name no existe en la base solicitada. 409 Conflict : violaci\u00f3n de restricciones ( UNIQUE , NOT NULL , etc.). GET /databases/{db_name}/fetch Devuelve todas las filas de la tabla e incluye el nombre de cada columna en la respuesta para facilitar el consumo desde clientes gen\u00e9ricos. La clave data es un alias de rows para mantener compatibilidad con integraciones previas. Query : table_name (obligatorio) curl -X GET \"http://127.0.0.1:8000/databases/demo/fetch?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" Nota: Los c\u00f3digos 404 pueden aparecer tanto en lecturas como en inserciones o borrados cuando la tabla indicada no existe. Respuesta de ejemplo: { \"columns\": [\"id\", \"msg\", \"created_at\", \"payload\"], \"rows\": [ [1, \"Texto desde la API\", \"2025-05-30T10:00:00\", \"base64:AQID\"] ], \"data\": [ [1, \"Texto desde la API\", \"2025-05-30T10:00:00\", \"base64:AQID\"] ] } Los valores binarios se devuelven como cadenas con prefijo base64: . Los objetos date , time o datetime se serializan en formato ISO 8601. Reglas generales Todos los endpoints (excepto token ) exigen Authorization: Bearer <token> . Los nombres de base de datos se normalizan y deben terminar en .db o se a\u00f1ade el sufijo. Los gestores asincr\u00f3nico y s\u00edncrono fuerzan PRAGMA journal_mode=WAL para mejorar la concurrencia.","title":"API REST - SQLitePlus Enhanced"},{"location":"api/#api-rest-sqliteplus-enhanced","text":"La API ofrece operaciones CRUD sobre m\u00faltiples bases SQLite protegidas por JWT. Swagger disponible en: http://localhost:8000/docs","title":"API REST - SQLitePlus Enhanced"},{"location":"api/#autenticacion","text":"","title":"Autenticaci\u00f3n"},{"location":"api/#post-token","text":"Genera un token JWT v\u00e1lido por una hora. Las credenciales se validan contra el archivo definido en SQLITEPLUS_USERS_FILE . Nota: la ruta se anuncia de forma relativa en el esquema OpenAPI, por lo que en despliegues con root_path o montajes aparecer\u00e1 como <prefijo>/token . Body (form-urlencoded) username password Respuestas 200 OK : { \"access_token\": \"<jwt>\", \"token_type\": \"bearer\" } 400 Bad Request : credenciales incorrectas o formulario inv\u00e1lido. 500 Internal Server Error : problemas al cargar el archivo de usuarios.","title":"POST /token"},{"location":"api/#gestion-de-tablas","text":"","title":"Gesti\u00f3n de tablas"},{"location":"api/#post-databasesdb_namecreate_table","text":"Crea una tabla si no existe. Los nombres de columnas se validan mediante CreateTableSchema y se escapan con comillas dobles. Normalizaci\u00f3n y validaciones de nombres Se eliminan espacios iniciales/finales de cada nombre antes de validar el patr\u00f3n de SQLite. La comparaci\u00f3n para detectar duplicados se hace con casefold() , por lo que \"Nombre\" y \" nombre \" se consideran el mismo identificador. Si despu\u00e9s de normalizar hay nombres repetidos, la API responde con 400 Bad Request . Query : table_name (puede incluir espacios o guiones; la API lo escapar\u00e1 autom\u00e1ticamente) Body : { \"columns\": { \"id\": \"INTEGER PRIMARY KEY\", \"msg\": \"TEXT\", \"created_at\": \"TEXT\" } } Errores comunes 400 : nombre de tabla inv\u00e1lido, columnas duplicadas o tipos vac\u00edos. 500 : error inesperado en la base.","title":"POST /databases/{db_name}/create_table"},{"location":"api/#delete-databasesdb_namedrop_table","text":"Elimina la tabla indicada. No falla si la tabla no existe. Query : table_name (obligatorio) curl -X DELETE \"http://127.0.0.1:8000/databases/demo/drop_table?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\"","title":"DELETE /databases/{db_name}/drop_table"},{"location":"api/#operaciones-crud","text":"","title":"Operaciones CRUD"},{"location":"api/#post-databasesdb_nameinsert","text":"Inserta un registro en la tabla especificada. El payload puede llegar ya normalizado bajo la clave values o como un objeto plano (por compatibilidad con clientes sencillos); en este \u00faltimo caso, la API lo reestructura internamente a {\"values\": { ... }} antes de procesarlo. Query : table_name (obligatorio) Body (JSON) : { \"values\": { \"columna\": \"valor\", ... } } o { \"columna\": \"valor\", ... } curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{ \"values\": { \"msg\": \"Texto desde la API\" } }' curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"msg\": \"Texto\"}' 404 Not Found : la tabla indicada en table_name no existe en la base solicitada. 409 Conflict : violaci\u00f3n de restricciones ( UNIQUE , NOT NULL , etc.).","title":"POST /databases/{db_name}/insert"},{"location":"api/#get-databasesdb_namefetch","text":"Devuelve todas las filas de la tabla e incluye el nombre de cada columna en la respuesta para facilitar el consumo desde clientes gen\u00e9ricos. La clave data es un alias de rows para mantener compatibilidad con integraciones previas. Query : table_name (obligatorio) curl -X GET \"http://127.0.0.1:8000/databases/demo/fetch?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" Nota: Los c\u00f3digos 404 pueden aparecer tanto en lecturas como en inserciones o borrados cuando la tabla indicada no existe. Respuesta de ejemplo: { \"columns\": [\"id\", \"msg\", \"created_at\", \"payload\"], \"rows\": [ [1, \"Texto desde la API\", \"2025-05-30T10:00:00\", \"base64:AQID\"] ], \"data\": [ [1, \"Texto desde la API\", \"2025-05-30T10:00:00\", \"base64:AQID\"] ] } Los valores binarios se devuelven como cadenas con prefijo base64: . Los objetos date , time o datetime se serializan en formato ISO 8601.","title":"GET /databases/{db_name}/fetch"},{"location":"api/#reglas-generales","text":"Todos los endpoints (excepto token ) exigen Authorization: Bearer <token> . Los nombres de base de datos se normalizan y deben terminar en .db o se a\u00f1ade el sufijo. Los gestores asincr\u00f3nico y s\u00edncrono fuerzan PRAGMA journal_mode=WAL para mejorar la concurrencia.","title":"Reglas generales"},{"location":"changelog/","text":"Resumen del historial de cambios Esta p\u00e1gina resume los principales hitos publicados en el proyecto. Para revisar el detalle completo consulta el CHANGELOG en GitHub . Unreleased Sin entradas por ahora. 1.0.9 \u00b7 2025-11-14 CLI renovada con comandos de inspecci\u00f3n ( list-tables , describe-table , db-info ) y paneles FletPlus para explorar la base. Tablas y paneles enriquecidos con Rich, junto a m\u00e9todos s\u00edncronos que replican las operaciones de la CLI y mejoran la salida de fetch . Validaciones adicionales en nombres y rutas de bases/usuarios, reorganizaci\u00f3n de extras ( dev , redis ) y parches de seguridad en dependencias cr\u00edticas. 1.0.7 \u00b7 2025-06-01 Documentaci\u00f3n general actualizada para reflejar la configuraci\u00f3n mediante SQLITEPLUS_USERS_FILE y los nuevos flujos de trabajo. Gu\u00edas de MkDocs sincronizadas con las capacidades actuales de la librer\u00eda. Informaci\u00f3n operativa sobre recarga de usuarios, reinicios autom\u00e1ticos y soporte opcional para SQLCipher. 1.0.4 \u00b7 2025-05-22 Arquitectura modular dividida en core/ , api/ , auth/ y utils/ . CLI interactiva, API REST con Swagger y gestor as\u00edncrono basado en aiosqlite . Integraci\u00f3n de SQLCipher, soporte multi-base de datos, exportaciones CSV/backups y pipeline de publicaci\u00f3n en PyPI. 1.0.3 \u00b7 2025-03-03 Documentaci\u00f3n inicial y ampliaci\u00f3n del README. Primera versi\u00f3n de los endpoints en FastAPI. 1.0.2 \u00b7 2025-03-03 Correcciones en el servidor as\u00edncrono (actualmente en sqliteplus/core/db.py ) para soportar m\u00faltiples clientes simult\u00e1neos. Nota: tras la refactorizaci\u00f3n de la versi\u00f3n 1.0.4 la funcionalidad de server_async.py se consolid\u00f3 en sqliteplus/core/db.py para mantener un \u00fanico gestor. 1.0.0 \u00b7 2025-03-02 Prototipo inicial de SQLitePlus basado en FastAPI.","title":"Resumen del historial de cambios"},{"location":"changelog/#resumen-del-historial-de-cambios","text":"Esta p\u00e1gina resume los principales hitos publicados en el proyecto. Para revisar el detalle completo consulta el CHANGELOG en GitHub .","title":"Resumen del historial de cambios"},{"location":"changelog/#unreleased","text":"Sin entradas por ahora.","title":"Unreleased"},{"location":"changelog/#109-2025-11-14","text":"CLI renovada con comandos de inspecci\u00f3n ( list-tables , describe-table , db-info ) y paneles FletPlus para explorar la base. Tablas y paneles enriquecidos con Rich, junto a m\u00e9todos s\u00edncronos que replican las operaciones de la CLI y mejoran la salida de fetch . Validaciones adicionales en nombres y rutas de bases/usuarios, reorganizaci\u00f3n de extras ( dev , redis ) y parches de seguridad en dependencias cr\u00edticas.","title":"1.0.9 \u00b7 2025-11-14"},{"location":"changelog/#107-2025-06-01","text":"Documentaci\u00f3n general actualizada para reflejar la configuraci\u00f3n mediante SQLITEPLUS_USERS_FILE y los nuevos flujos de trabajo. Gu\u00edas de MkDocs sincronizadas con las capacidades actuales de la librer\u00eda. Informaci\u00f3n operativa sobre recarga de usuarios, reinicios autom\u00e1ticos y soporte opcional para SQLCipher.","title":"1.0.7 \u00b7 2025-06-01"},{"location":"changelog/#104-2025-05-22","text":"Arquitectura modular dividida en core/ , api/ , auth/ y utils/ . CLI interactiva, API REST con Swagger y gestor as\u00edncrono basado en aiosqlite . Integraci\u00f3n de SQLCipher, soporte multi-base de datos, exportaciones CSV/backups y pipeline de publicaci\u00f3n en PyPI.","title":"1.0.4 \u00b7 2025-05-22"},{"location":"changelog/#103-2025-03-03","text":"Documentaci\u00f3n inicial y ampliaci\u00f3n del README. Primera versi\u00f3n de los endpoints en FastAPI.","title":"1.0.3 \u00b7 2025-03-03"},{"location":"changelog/#102-2025-03-03","text":"Correcciones en el servidor as\u00edncrono (actualmente en sqliteplus/core/db.py ) para soportar m\u00faltiples clientes simult\u00e1neos. Nota: tras la refactorizaci\u00f3n de la versi\u00f3n 1.0.4 la funcionalidad de server_async.py se consolid\u00f3 en sqliteplus/core/db.py para mantener un \u00fanico gestor.","title":"1.0.2 \u00b7 2025-03-03"},{"location":"changelog/#100-2025-03-02","text":"Prototipo inicial de SQLitePlus basado en FastAPI.","title":"1.0.0 \u00b7 2025-03-02"},{"location":"cli/","text":"CLI sqliteplus El paquete instala el comando sqliteplus , pensado para quienes prefieren gestionar la base sin levantar la API. El comando principal acepta dos opciones globales: --cipher-key (o la variable SQLITE_DB_KEY ) para abrir bases cifradas. --db-path para indicar qu\u00e9 archivo .db usar\u00e1n los subcomandos. Inicializar la base sqliteplus init-db Si la base no existe se crea autom\u00e1ticamente y se anota la acci\u00f3n en la tabla logs . El mensaje de salida confirma la ruta final del archivo. Ejecutar consultas de escritura sqliteplus execute INSERT INTO logs (action) VALUES ('Mensaje desde CLI') El comando muestra un mensaje de \u00e9xito y, cuando hay una inserci\u00f3n, informa el \u00faltimo ID generado. Los errores de SQLite se convierten en mensajes claros de Click. Consultar informaci\u00f3n sqliteplus fetch SELECT * FROM logs Los resultados aparecen fila a fila. Si la consulta no devuelve datos el programa lo avisa para evitar confusiones. Usa --summary para generar una tabla adicional con m\u00ednimos, m\u00e1ximos y promedios de las columnas num\u00e9ricas. Con --viewer se abre un visor accesible construido con FletPlus; admite filtros en vivo, cambio de tema ( --viewer-theme ) y ajuste del tama\u00f1o del texto. Si necesitas paginar conjuntos grandes, combina --viewer con --viewer-page-size o --viewer-virtual para cargar filas bajo demanda. Cuando eliges --output json , cada valor de la consulta se normaliza antes de mostrarse: los BLOBs se codifican en Base64, los Decimal se convierten a n\u00fameros o cadenas y las fechas/horas se expresan en ISO 8601, evitando errores de serializaci\u00f3n. Para usar --viewer debes instalar el extra opcional visual : pip install \"sqliteplus-enhanced[visual]\" . Comandos y flags que requieren el extra visual Los visores interactivos de FletPlus solo est\u00e1n disponibles cuando instalas el extra visual . Inst\u00e1lalo si necesitas alguno de los siguientes flujos: sqliteplus fetch --viewer : habilita una cuadr\u00edcula interactiva donde tambi\u00e9n puedes combinar --viewer-theme , --viewer-page-size y --viewer-virtual para ajustar el aspecto y la paginaci\u00f3n. sqliteplus list-tables --viewer : muestra un panel navegable para explorar tablas y vistas con filtros y ordenaci\u00f3n. sqliteplus visual-dashboard : abre el panel completo de FletPlus y admite los flags --theme , --accent-color y --max-rows para personalizar el entorno. Listar tablas disponibles sqliteplus list-tables Muestra una tabla con todas las tablas de usuario y el n\u00famero de filas registradas. A\u00f1ade --include-views si tambi\u00e9n quieres ver las vistas definidas. Con --viewer obtienes un cat\u00e1logo visual donde puedes ordenar y navegar por los objetos con ayuda de la \u00faltima versi\u00f3n de FletPlus. Describir la estructura de una tabla sqliteplus describe-table logs Obtendr\u00e1s un resumen con el n\u00famero de filas, columnas, \u00edndices y claves for\u00e1neas de la tabla seleccionada. Ver estad\u00edsticas generales sqliteplus db-info Imprime la ruta del archivo activo, su tama\u00f1o en disco y el total de tablas, vistas y filas. Panel visual con FletPlus sqliteplus visual-dashboard --theme dark --accent-color BLUE_200 Abre un panel enriquecido que aprovecha la nueva actualizaci\u00f3n de FletPlus. Puedes elegir el tema ( --theme ), personalizar el color primario ( --accent-color ) y navegar por vistas dedicadas a resumen, consultas, historial y ayudas de accesibilidad. Desde el propio panel es posible acceder a la paleta de comandos (Ctrl+K) o consultar los consejos incorporados. Este comando tambi\u00e9n requiere instalar el extra visual mediante pip install \"sqliteplus-enhanced[visual]\" . Escenario manual: validar max_rows en visual-dashboard Ejecuta sqliteplus init-db y crea una tabla con al menos 1\u202f000 filas usando \u00fanicamente comandos compatibles con cualquier instalaci\u00f3n base: bash sqliteplus execute \"CREATE TABLE IF NOT EXISTS demo (id INTEGER PRIMARY KEY, note TEXT)\" sqliteplus execute \"WITH RECURSIVE counter(x) AS (SELECT 1 UNION ALL SELECT x + 1 FROM counter WHERE x < 1000) INSERT INTO demo(note) SELECT printf('fila %d', x) FROM counter\" Abre el panel con sqliteplus visual-dashboard --max-rows 25 y dir\u00edgete a la pesta\u00f1a de consultas. Lanza SELECT * FROM demo sin cl\u00e1usula LIMIT . El panel solo mostrar\u00e1 25 filas y el mensaje inferior indicar\u00e1 que la consulta se trunc\u00f3 por el l\u00edmite configurado. Repite la consulta a\u00f1adiendo LIMIT 10 para comprobar que el mensaje cambia y ya no se advierte truncamiento. Si prefieres usar extensiones como generate_series , recuerda cargar expl\u00edcitamente la extensi\u00f3n antes de ejecutar los ejemplos ( SELECT load_extension('mod_spatialite'); , etc.). El tutorial incluye instrucciones que funcionan sin extensiones para que puedas copiar y pegar los comandos en la CLI est\u00e1ndar de inmediato. Exportar una tabla a CSV sqliteplus export-csv logs logs.csv Genera un CSV con encabezados listo para compartir. Puedes utilizar nombres de tabla con espacios o guiones ( \"logs con espacios\" , \"logs-con-guion\" ), la herramienta se encarga de escaparlos sin perder seguridad. Si necesitas otra base diferente a la global, a\u00f1ade --db-path /ruta/a/otra.db . De forma predeterminada, export-csv evita sobrescribir archivos ya existentes para que no pierdas datos accidentalmente. Si realmente deseas reemplazar el archivo, pasa el flag --overwrite y el comando continuar\u00e1 sin detenerse. Nota: la utilidad SQLiteReplication.export_to_csv \u00fanicamente devuelve la ruta final; la CLI se encarga de mostrarla en un panel Rich para evitar mensajes duplicados cuando reutilices la funci\u00f3n desde tus propios scripts. Exportar resultados de una consulta sqliteplus export-query --format json resultados.json \"SELECT * FROM logs ORDER BY created_at DESC\" Permite ejecutar una consulta SELECT y guardar el resultado en un archivo JSON o CSV sin pasar por la API. Es \u00fatil para compartir subconjuntos filtrados o preparar datos para otras herramientas sin modificar la base. --format controla el formato de salida ( json por defecto o csv ). --limit restringe el n\u00famero de filas exportadas sin alterar la consulta original. --overwrite habilita la sobrescritura del archivo de destino cuando ya existe. Cuando eliges --format json , los valores especiales se transforman autom\u00e1ticamente para garantizar que el archivo pueda serializarse sin errores: los BLOBs y memoryview se codifican en Base64 con el prefijo base64: , los Decimal se convierten a n\u00fameros de punto flotante (o cadenas si exceden el rango) y las fechas/horas se expresan en ISO 8601. Adem\u00e1s, si una columna carece de nombre o SQLite retorna una cadena vac\u00eda, el comando genera encabezados gen\u00e9ricos ( columna_1 , columna_2 , etc.) para asegurar claves v\u00e1lidas en cada registro JSON. Si optas por CSV ocurre lo mismo: se respetan los nombres de columna provistos por la consulta, pero los huecos o celdas sin alias se sustituyen por esos identificadores autom\u00e1ticos, manteniendo la estructura tabular coherente. sqliteplus export-query --format csv --limit 100 --overwrite resumen.csv \\ \"SELECT level, COUNT(*) AS eventos FROM logs GROUP BY level ORDER BY level\" Cuando la consulta no devuelve nombres de columna o estos llegan vac\u00edos (por ejemplo, al usar SELECT '' AS \"\" o expresiones similares), la CLI crea los encabezados columna_n para mantener una estructura coherente en el archivo final. Crear copias de seguridad sqliteplus backup Obtendr\u00e1s un respaldo fechado en la carpeta backups/ . El comando indica el archivo final. Tambi\u00e9n puedes pasar --db-path para copiar una base concreta. De forma an\u00e1loga, SQLiteReplication.backup_database retorna la ubicaci\u00f3n creada sin imprimir mensajes directos, lo que garantiza que toda la salida visible provenga de la CLI y puedas reutilizar la funci\u00f3n en otros contextos. Trabajar con SQLCipher sqliteplus --cipher-key \"$SQLITE_DB_KEY\" backup Si la clave es incorrecta o el int\u00e9rprete no soporta SQLCipher, la CLI mostrar\u00e1 un error f\u00e1cil de entender para guiarte en la correcci\u00f3n. Nuevo aspecto con Rich Gracias a la librer\u00eda Rich , todos los comandos muestran tablas, paneles y colores que facilitan la lectura, especialmente en pantallas oscuras o cuando necesitas compartir los resultados por terminal.","title":"CLI sqliteplus"},{"location":"cli/#cli-sqliteplus","text":"El paquete instala el comando sqliteplus , pensado para quienes prefieren gestionar la base sin levantar la API. El comando principal acepta dos opciones globales: --cipher-key (o la variable SQLITE_DB_KEY ) para abrir bases cifradas. --db-path para indicar qu\u00e9 archivo .db usar\u00e1n los subcomandos.","title":"CLI sqliteplus"},{"location":"cli/#inicializar-la-base","text":"sqliteplus init-db Si la base no existe se crea autom\u00e1ticamente y se anota la acci\u00f3n en la tabla logs . El mensaje de salida confirma la ruta final del archivo.","title":"Inicializar la base"},{"location":"cli/#ejecutar-consultas-de-escritura","text":"sqliteplus execute INSERT INTO logs (action) VALUES ('Mensaje desde CLI') El comando muestra un mensaje de \u00e9xito y, cuando hay una inserci\u00f3n, informa el \u00faltimo ID generado. Los errores de SQLite se convierten en mensajes claros de Click.","title":"Ejecutar consultas de escritura"},{"location":"cli/#consultar-informacion","text":"sqliteplus fetch SELECT * FROM logs Los resultados aparecen fila a fila. Si la consulta no devuelve datos el programa lo avisa para evitar confusiones. Usa --summary para generar una tabla adicional con m\u00ednimos, m\u00e1ximos y promedios de las columnas num\u00e9ricas. Con --viewer se abre un visor accesible construido con FletPlus; admite filtros en vivo, cambio de tema ( --viewer-theme ) y ajuste del tama\u00f1o del texto. Si necesitas paginar conjuntos grandes, combina --viewer con --viewer-page-size o --viewer-virtual para cargar filas bajo demanda. Cuando eliges --output json , cada valor de la consulta se normaliza antes de mostrarse: los BLOBs se codifican en Base64, los Decimal se convierten a n\u00fameros o cadenas y las fechas/horas se expresan en ISO 8601, evitando errores de serializaci\u00f3n. Para usar --viewer debes instalar el extra opcional visual : pip install \"sqliteplus-enhanced[visual]\" .","title":"Consultar informaci\u00f3n"},{"location":"cli/#comandos-y-flags-que-requieren-el-extra-visual","text":"Los visores interactivos de FletPlus solo est\u00e1n disponibles cuando instalas el extra visual . Inst\u00e1lalo si necesitas alguno de los siguientes flujos: sqliteplus fetch --viewer : habilita una cuadr\u00edcula interactiva donde tambi\u00e9n puedes combinar --viewer-theme , --viewer-page-size y --viewer-virtual para ajustar el aspecto y la paginaci\u00f3n. sqliteplus list-tables --viewer : muestra un panel navegable para explorar tablas y vistas con filtros y ordenaci\u00f3n. sqliteplus visual-dashboard : abre el panel completo de FletPlus y admite los flags --theme , --accent-color y --max-rows para personalizar el entorno.","title":"Comandos y flags que requieren el extra visual"},{"location":"cli/#listar-tablas-disponibles","text":"sqliteplus list-tables Muestra una tabla con todas las tablas de usuario y el n\u00famero de filas registradas. A\u00f1ade --include-views si tambi\u00e9n quieres ver las vistas definidas. Con --viewer obtienes un cat\u00e1logo visual donde puedes ordenar y navegar por los objetos con ayuda de la \u00faltima versi\u00f3n de FletPlus.","title":"Listar tablas disponibles"},{"location":"cli/#describir-la-estructura-de-una-tabla","text":"sqliteplus describe-table logs Obtendr\u00e1s un resumen con el n\u00famero de filas, columnas, \u00edndices y claves for\u00e1neas de la tabla seleccionada.","title":"Describir la estructura de una tabla"},{"location":"cli/#ver-estadisticas-generales","text":"sqliteplus db-info Imprime la ruta del archivo activo, su tama\u00f1o en disco y el total de tablas, vistas y filas.","title":"Ver estad\u00edsticas generales"},{"location":"cli/#panel-visual-con-fletplus","text":"sqliteplus visual-dashboard --theme dark --accent-color BLUE_200 Abre un panel enriquecido que aprovecha la nueva actualizaci\u00f3n de FletPlus. Puedes elegir el tema ( --theme ), personalizar el color primario ( --accent-color ) y navegar por vistas dedicadas a resumen, consultas, historial y ayudas de accesibilidad. Desde el propio panel es posible acceder a la paleta de comandos (Ctrl+K) o consultar los consejos incorporados. Este comando tambi\u00e9n requiere instalar el extra visual mediante pip install \"sqliteplus-enhanced[visual]\" .","title":"Panel visual con FletPlus"},{"location":"cli/#escenario-manual-validar-max_rows-en-visual-dashboard","text":"Ejecuta sqliteplus init-db y crea una tabla con al menos 1\u202f000 filas usando \u00fanicamente comandos compatibles con cualquier instalaci\u00f3n base: bash sqliteplus execute \"CREATE TABLE IF NOT EXISTS demo (id INTEGER PRIMARY KEY, note TEXT)\" sqliteplus execute \"WITH RECURSIVE counter(x) AS (SELECT 1 UNION ALL SELECT x + 1 FROM counter WHERE x < 1000) INSERT INTO demo(note) SELECT printf('fila %d', x) FROM counter\" Abre el panel con sqliteplus visual-dashboard --max-rows 25 y dir\u00edgete a la pesta\u00f1a de consultas. Lanza SELECT * FROM demo sin cl\u00e1usula LIMIT . El panel solo mostrar\u00e1 25 filas y el mensaje inferior indicar\u00e1 que la consulta se trunc\u00f3 por el l\u00edmite configurado. Repite la consulta a\u00f1adiendo LIMIT 10 para comprobar que el mensaje cambia y ya no se advierte truncamiento. Si prefieres usar extensiones como generate_series , recuerda cargar expl\u00edcitamente la extensi\u00f3n antes de ejecutar los ejemplos ( SELECT load_extension('mod_spatialite'); , etc.). El tutorial incluye instrucciones que funcionan sin extensiones para que puedas copiar y pegar los comandos en la CLI est\u00e1ndar de inmediato.","title":"Escenario manual: validar max_rows en visual-dashboard"},{"location":"cli/#exportar-una-tabla-a-csv","text":"sqliteplus export-csv logs logs.csv Genera un CSV con encabezados listo para compartir. Puedes utilizar nombres de tabla con espacios o guiones ( \"logs con espacios\" , \"logs-con-guion\" ), la herramienta se encarga de escaparlos sin perder seguridad. Si necesitas otra base diferente a la global, a\u00f1ade --db-path /ruta/a/otra.db . De forma predeterminada, export-csv evita sobrescribir archivos ya existentes para que no pierdas datos accidentalmente. Si realmente deseas reemplazar el archivo, pasa el flag --overwrite y el comando continuar\u00e1 sin detenerse. Nota: la utilidad SQLiteReplication.export_to_csv \u00fanicamente devuelve la ruta final; la CLI se encarga de mostrarla en un panel Rich para evitar mensajes duplicados cuando reutilices la funci\u00f3n desde tus propios scripts.","title":"Exportar una tabla a CSV"},{"location":"cli/#exportar-resultados-de-una-consulta","text":"sqliteplus export-query --format json resultados.json \"SELECT * FROM logs ORDER BY created_at DESC\" Permite ejecutar una consulta SELECT y guardar el resultado en un archivo JSON o CSV sin pasar por la API. Es \u00fatil para compartir subconjuntos filtrados o preparar datos para otras herramientas sin modificar la base. --format controla el formato de salida ( json por defecto o csv ). --limit restringe el n\u00famero de filas exportadas sin alterar la consulta original. --overwrite habilita la sobrescritura del archivo de destino cuando ya existe. Cuando eliges --format json , los valores especiales se transforman autom\u00e1ticamente para garantizar que el archivo pueda serializarse sin errores: los BLOBs y memoryview se codifican en Base64 con el prefijo base64: , los Decimal se convierten a n\u00fameros de punto flotante (o cadenas si exceden el rango) y las fechas/horas se expresan en ISO 8601. Adem\u00e1s, si una columna carece de nombre o SQLite retorna una cadena vac\u00eda, el comando genera encabezados gen\u00e9ricos ( columna_1 , columna_2 , etc.) para asegurar claves v\u00e1lidas en cada registro JSON. Si optas por CSV ocurre lo mismo: se respetan los nombres de columna provistos por la consulta, pero los huecos o celdas sin alias se sustituyen por esos identificadores autom\u00e1ticos, manteniendo la estructura tabular coherente. sqliteplus export-query --format csv --limit 100 --overwrite resumen.csv \\ \"SELECT level, COUNT(*) AS eventos FROM logs GROUP BY level ORDER BY level\" Cuando la consulta no devuelve nombres de columna o estos llegan vac\u00edos (por ejemplo, al usar SELECT '' AS \"\" o expresiones similares), la CLI crea los encabezados columna_n para mantener una estructura coherente en el archivo final.","title":"Exportar resultados de una consulta"},{"location":"cli/#crear-copias-de-seguridad","text":"sqliteplus backup Obtendr\u00e1s un respaldo fechado en la carpeta backups/ . El comando indica el archivo final. Tambi\u00e9n puedes pasar --db-path para copiar una base concreta. De forma an\u00e1loga, SQLiteReplication.backup_database retorna la ubicaci\u00f3n creada sin imprimir mensajes directos, lo que garantiza que toda la salida visible provenga de la CLI y puedas reutilizar la funci\u00f3n en otros contextos.","title":"Crear copias de seguridad"},{"location":"cli/#trabajar-con-sqlcipher","text":"sqliteplus --cipher-key \"$SQLITE_DB_KEY\" backup Si la clave es incorrecta o el int\u00e9rprete no soporta SQLCipher, la CLI mostrar\u00e1 un error f\u00e1cil de entender para guiarte en la correcci\u00f3n.","title":"Trabajar con SQLCipher"},{"location":"cli/#nuevo-aspecto-con-rich","text":"Gracias a la librer\u00eda Rich , todos los comandos muestran tablas, paneles y colores que facilitan la lectura, especialmente en pantallas oscuras o cuando necesitas compartir los resultados por terminal.","title":"Nuevo aspecto con Rich"},{"location":"configuracion/","text":"Configuraci\u00f3n avanzada Variables de entorno soportadas Variable Descripci\u00f3n HOME Utilizada al expandir rutas con ~ en SQLITEPLUS_USERS_FILE . PYTEST_CURRENT_TEST Detectada autom\u00e1ticamente por pytest para reiniciar bases temporales. SECRET_KEY Clave obligatoria para firmar JWT. Se valida en tiempo de ejecuci\u00f3n. SQLITEPLUS_FORCE_RESET Fuerza la reinicializaci\u00f3n de las bases sin depender de PYTEST_CURRENT_TEST . Admite 1 , true o on . La secci\u00f3n \"Reinicializaci\u00f3n autom\u00e1tica en pruebas\" de docs/uso_avanzado.md detalla el flujo. SQLITEPLUS_USERS_FILE Ruta (admite ~ ) del archivo JSON con usuarios y hashes bcrypt . Solo es obligatorio al exponer la API/autenticaci\u00f3n. SQLITE_DB_KEY Clave SQLCipher opcional. Si no existe, se omite el cifrado. Directorios de trabajo Las bases asincr\u00f3nicas se almacenan en la carpeta databases/ por defecto. Las copias de seguridad generadas por la CLI residen en backups/ . SQLiteReplication copia los ficheros -wal y -shm asociados para mantener la integridad. Opciones de la CLI --cipher-key / SQLITE_DB_KEY : permite usar SQLCipher en las operaciones sincr\u00f3nicas. Los subcomandos export-csv y backup aceptan rutas personalizadas conservando nombres seguros. Autenticaci\u00f3n externa El archivo apuntado por SQLITEPLUS_USERS_FILE debe tener la estructura: { \"admin\": \"$2b$12$...\" } Puedes generar nuevos hashes con el m\u00f3dulo bcrypt desde Python, tal como se muestra en la gu\u00eda de uso b\u00e1sico.","title":"Configuraci\u00f3n avanzada"},{"location":"configuracion/#configuracion-avanzada","text":"","title":"Configuraci\u00f3n avanzada"},{"location":"configuracion/#variables-de-entorno-soportadas","text":"Variable Descripci\u00f3n HOME Utilizada al expandir rutas con ~ en SQLITEPLUS_USERS_FILE . PYTEST_CURRENT_TEST Detectada autom\u00e1ticamente por pytest para reiniciar bases temporales. SECRET_KEY Clave obligatoria para firmar JWT. Se valida en tiempo de ejecuci\u00f3n. SQLITEPLUS_FORCE_RESET Fuerza la reinicializaci\u00f3n de las bases sin depender de PYTEST_CURRENT_TEST . Admite 1 , true o on . La secci\u00f3n \"Reinicializaci\u00f3n autom\u00e1tica en pruebas\" de docs/uso_avanzado.md detalla el flujo. SQLITEPLUS_USERS_FILE Ruta (admite ~ ) del archivo JSON con usuarios y hashes bcrypt . Solo es obligatorio al exponer la API/autenticaci\u00f3n. SQLITE_DB_KEY Clave SQLCipher opcional. Si no existe, se omite el cifrado.","title":"Variables de entorno soportadas"},{"location":"configuracion/#directorios-de-trabajo","text":"Las bases asincr\u00f3nicas se almacenan en la carpeta databases/ por defecto. Las copias de seguridad generadas por la CLI residen en backups/ . SQLiteReplication copia los ficheros -wal y -shm asociados para mantener la integridad.","title":"Directorios de trabajo"},{"location":"configuracion/#opciones-de-la-cli","text":"--cipher-key / SQLITE_DB_KEY : permite usar SQLCipher en las operaciones sincr\u00f3nicas. Los subcomandos export-csv y backup aceptan rutas personalizadas conservando nombres seguros.","title":"Opciones de la CLI"},{"location":"configuracion/#autenticacion-externa","text":"El archivo apuntado por SQLITEPLUS_USERS_FILE debe tener la estructura: { \"admin\": \"$2b$12$...\" } Puedes generar nuevos hashes con el m\u00f3dulo bcrypt desde Python, tal como se muestra en la gu\u00eda de uso b\u00e1sico.","title":"Autenticaci\u00f3n externa"},{"location":"endpoints/","text":"Endpoints REST Resumen r\u00e1pido de los recursos disponibles. Todos requieren Authorization: Bearer <token> salvo la ruta de autenticaci\u00f3n token (que se publicar\u00e1 respetando el root_path ). Autenticaci\u00f3n POST /token \u2013 genera un JWT firmado con SECRET_KEY . Usa el fichero SQLITEPLUS_USERS_FILE y se mostrar\u00e1 como <prefijo>/token cuando la app se monte bajo un prefijo. Gesti\u00f3n de bases y tablas POST /databases/{db_name}/create_table \u2013 valida columnas con Pydantic, escapa identificadores y requiere table_name como par\u00e1metro de consulta (por ejemplo, /databases/db_demo/create_table?table_name=clientes ). DELETE /databases/{db_name}/drop_table \u2013 elimina la tabla si existe y tambi\u00e9n exige table_name como query (ejemplo: /databases/db_demo/drop_table?table_name=clientes ). Operaciones CRUD POST /databases/{db_name}/insert \u2013 inserta filas usando placeholders ? , requiere table_name como query y responde con 404 si la tabla no existe. GET /databases/{db_name}/fetch \u2013 devuelve todas las filas de la tabla indicado en table_name ; responde con 404 si la tabla no existe. Consulta docs/api.md para conocer los cuerpos de petici\u00f3n y respuestas detalladas.","title":"Endpoints REST"},{"location":"endpoints/#endpoints-rest","text":"Resumen r\u00e1pido de los recursos disponibles. Todos requieren Authorization: Bearer <token> salvo la ruta de autenticaci\u00f3n token (que se publicar\u00e1 respetando el root_path ).","title":"Endpoints REST"},{"location":"endpoints/#autenticacion","text":"POST /token \u2013 genera un JWT firmado con SECRET_KEY . Usa el fichero SQLITEPLUS_USERS_FILE y se mostrar\u00e1 como <prefijo>/token cuando la app se monte bajo un prefijo.","title":"Autenticaci\u00f3n"},{"location":"endpoints/#gestion-de-bases-y-tablas","text":"POST /databases/{db_name}/create_table \u2013 valida columnas con Pydantic, escapa identificadores y requiere table_name como par\u00e1metro de consulta (por ejemplo, /databases/db_demo/create_table?table_name=clientes ). DELETE /databases/{db_name}/drop_table \u2013 elimina la tabla si existe y tambi\u00e9n exige table_name como query (ejemplo: /databases/db_demo/drop_table?table_name=clientes ).","title":"Gesti\u00f3n de bases y tablas"},{"location":"endpoints/#operaciones-crud","text":"POST /databases/{db_name}/insert \u2013 inserta filas usando placeholders ? , requiere table_name como query y responde con 404 si la tabla no existe. GET /databases/{db_name}/fetch \u2013 devuelve todas las filas de la tabla indicado en table_name ; responde con 404 si la tabla no existe. Consulta docs/api.md para conocer los cuerpos de petici\u00f3n y respuestas detalladas.","title":"Operaciones CRUD"},{"location":"instalacion/","text":"Instalaci\u00f3n Requisitos previos Python 3.10 o superior. Una versi\u00f3n moderna de SQLite (el soporte para WAL viene incluido y el proyecto aplica PRAGMA journal_mode=WAL autom\u00e1ticamente). Opcional: Redis (la integraci\u00f3n de cach\u00e9 est\u00e1 en desarrollo; consulta el CHANGELOG para conocer el estado actual del extra redis ). Desde el repositorio python -m venv .venv source .venv/bin/activate pip install -e . Si vas a ejecutar las pruebas, el lint o contribuir con cambios instala tambi\u00e9n las dependencias opcionales y, a continuaci\u00f3n, ejecuta la suite con Pytest: pip install -e '.[dev]' pytest -v Nota: La integraci\u00f3n con Redis a\u00fan no est\u00e1 disponible en la aplicaci\u00f3n. El extra redis \u00fanicamente instala las dependencias preliminares y puede cambiar en futuras versiones. Revisa el CHANGELOG para seguir el progreso. Nota r\u00e1pida: No necesitas ninguna configuraci\u00f3n manual adicional: el c\u00f3digo fuerza PRAGMA journal_mode=WAL cada vez que abre una conexi\u00f3n (consulta sqliteplus/core/db.py y sqliteplus/utils/sqliteplus_sync.py ). Si aun as\u00ed deseas preparar el entorno con las dependencias de Redis instala el extra: pip install -e '.[redis]' Extra visual La instalaci\u00f3n principal ya incluye Rich, as\u00ed que todas las tablas, paneles y mensajes de la CLI lucen correctamente sin pasos adicionales. El extra visual es opcional y a\u00f1ade \u00fanicamente las dependencias de los visores interactivos basados en FletPlus. Inst\u00e1lalo solo si planeas usar los subcomandos o flags que abren esos visores ( sqliteplus fetch --viewer , sqliteplus list-tables --viewer , sqliteplus visual-dashboard , etc.). Puedes consultar la lista completa en docs/cli.md para comprobar r\u00e1pidamente si lo necesitas. pip install -e '.[visual]' Nota: Consulta docs/cli.md para revisar los comandos que requieren el extra visual . Desde PyPI pip install sqliteplus-enhanced Nota: La integraci\u00f3n con Redis est\u00e1 pendiente; instalar sqliteplus-enhanced[redis] solo a\u00f1ade las dependencias necesarias para futuras versiones. Consulta el CHANGELOG para conocer el estado actualizado. Para incluir estas dependencias opcionales de Redis usa: pip install 'sqliteplus-enhanced[redis]' Para habilitar las capacidades visuales desde PyPI instala el extra correspondiente: pip install \"sqliteplus-enhanced[visual]\" Nota: En docs/cli.md encontrar\u00e1s los comandos que dependen del extra visual . Consejo: Las comillas simples evitan que shells como zsh intenten expandir los corchetes, lo que podr\u00eda generar errores al instalar los extras. La distribuci\u00f3n incluye el comando sqliteplus y el paquete sqliteplus.main listo para ejecutarse con Uvicorn.","title":"Instalaci\u00f3n"},{"location":"instalacion/#instalacion","text":"","title":"Instalaci\u00f3n"},{"location":"instalacion/#requisitos-previos","text":"Python 3.10 o superior. Una versi\u00f3n moderna de SQLite (el soporte para WAL viene incluido y el proyecto aplica PRAGMA journal_mode=WAL autom\u00e1ticamente). Opcional: Redis (la integraci\u00f3n de cach\u00e9 est\u00e1 en desarrollo; consulta el CHANGELOG para conocer el estado actual del extra redis ).","title":"Requisitos previos"},{"location":"instalacion/#desde-el-repositorio","text":"python -m venv .venv source .venv/bin/activate pip install -e . Si vas a ejecutar las pruebas, el lint o contribuir con cambios instala tambi\u00e9n las dependencias opcionales y, a continuaci\u00f3n, ejecuta la suite con Pytest: pip install -e '.[dev]' pytest -v Nota: La integraci\u00f3n con Redis a\u00fan no est\u00e1 disponible en la aplicaci\u00f3n. El extra redis \u00fanicamente instala las dependencias preliminares y puede cambiar en futuras versiones. Revisa el CHANGELOG para seguir el progreso. Nota r\u00e1pida: No necesitas ninguna configuraci\u00f3n manual adicional: el c\u00f3digo fuerza PRAGMA journal_mode=WAL cada vez que abre una conexi\u00f3n (consulta sqliteplus/core/db.py y sqliteplus/utils/sqliteplus_sync.py ). Si aun as\u00ed deseas preparar el entorno con las dependencias de Redis instala el extra: pip install -e '.[redis]'","title":"Desde el repositorio"},{"location":"instalacion/#extra-visual","text":"La instalaci\u00f3n principal ya incluye Rich, as\u00ed que todas las tablas, paneles y mensajes de la CLI lucen correctamente sin pasos adicionales. El extra visual es opcional y a\u00f1ade \u00fanicamente las dependencias de los visores interactivos basados en FletPlus. Inst\u00e1lalo solo si planeas usar los subcomandos o flags que abren esos visores ( sqliteplus fetch --viewer , sqliteplus list-tables --viewer , sqliteplus visual-dashboard , etc.). Puedes consultar la lista completa en docs/cli.md para comprobar r\u00e1pidamente si lo necesitas. pip install -e '.[visual]' Nota: Consulta docs/cli.md para revisar los comandos que requieren el extra visual .","title":"Extra visual"},{"location":"instalacion/#desde-pypi","text":"pip install sqliteplus-enhanced Nota: La integraci\u00f3n con Redis est\u00e1 pendiente; instalar sqliteplus-enhanced[redis] solo a\u00f1ade las dependencias necesarias para futuras versiones. Consulta el CHANGELOG para conocer el estado actualizado. Para incluir estas dependencias opcionales de Redis usa: pip install 'sqliteplus-enhanced[redis]' Para habilitar las capacidades visuales desde PyPI instala el extra correspondiente: pip install \"sqliteplus-enhanced[visual]\" Nota: En docs/cli.md encontrar\u00e1s los comandos que dependen del extra visual . Consejo: Las comillas simples evitan que shells como zsh intenten expandir los corchetes, lo que podr\u00eda generar errores al instalar los extras. La distribuci\u00f3n incluye el comando sqliteplus y el paquete sqliteplus.main listo para ejecutarse con Uvicorn.","title":"Desde PyPI"},{"location":"uso_avanzado/","text":"Casos de uso avanzados Reinicializaci\u00f3n autom\u00e1tica en pruebas AsyncDatabaseManager detecta la variable PYTEST_CURRENT_TEST y elimina autom\u00e1ticamente la base temporal antes de cada suite, evitando datos residuales entre ejecuciones. A partir de esta versi\u00f3n la comprobaci\u00f3n es perezosa: el gestor vuelve a leer PYTEST_CURRENT_TEST (y la variable SQLITEPLUS_FORCE_RESET ) cada vez que necesita crear una conexi\u00f3n. De este modo puedes activar el modo limpieza incluso si el objeto global ya estaba instanciado o si quieres forzar el borrado desde la app FastAPI (por ejemplo, antes de lanzar un lote de pruebas de integraci\u00f3n). Si la variable se activa cuando ya existe una conexi\u00f3n viva en el mismo bucle, el gestor la cierra, elimina los ficheros *.db , *.db-wal y *.db-shm y vuelve a levantar una base limpia. Usa valores como 1 , true o on para activar SQLITEPLUS_FORCE_RESET y elimina la variable cuando dejes de necesitar el borrado autom\u00e1tico. Conexiones por bucle de eventos Cuando se reutiliza el mismo nombre de base en distintos bucles de eventos (por ejemplo, al usar httpx.AsyncClient en paralelo), el gestor cierra y recrea la conexi\u00f3n para ese bucle, evitando errores de \"conexi\u00f3n ligada a otro loop\". Aplicar SQLCipher solo si existe clave Si SQLITE_DB_KEY est\u00e1 vac\u00edo, la API trabaja sin cifrado. Al definir la variable se ejecuta PRAGMA key y se propagan los posibles errores de SQLCipher en los logs. Replicaci\u00f3n y exportaciones automatizadas El m\u00f3dulo sqliteplus.utils.replication_sync.SQLiteReplication permite: backup_database() \u2013 genera copias fechadas y duplica ficheros WAL/SHM si existen. replicate_database(<ruta>) \u2013 clona la base en otra ruta aplicando la misma clave SQLCipher. export_to_csv(<tabla>, <archivo>) \u2013 exporta columnas y filas preservando el nombre de campos. A partir de esta versi\u00f3n, al instanciar SQLiteReplication() sin argumentos se crea una copia local en ./sqliteplus/databases/database.db , exactamente igual que hace la CLI. Esto evita que los procesos automatizados modifiquen el paquete instalado y garantiza que cualquier replicaci\u00f3n o exportaci\u00f3n parta de un archivo sobre el que se puede escribir en el directorio de trabajo. Cuando el origen solicitado est\u00e1 dentro del paquete o se detecta que no es escribible, el m\u00f3dulo realiza una copia byte a byte en el directorio local (incluyendo los pares -wal / -shm ). Si la base de datos original no existe se aborta la operaci\u00f3n con un mensaje claro en lugar de crear un archivo vac\u00edo. Actualizaci\u00f3n caliente de usuarios sqliteplus.auth.users.get_user_service() mantiene una cach\u00e9 basada en la firma del archivo. Al modificar SQLITEPLUS_USERS_FILE se detecta el cambio autom\u00e1ticamente y se recarga la lista de usuarios sin reiniciar el proceso.","title":"Casos de uso avanzados"},{"location":"uso_avanzado/#casos-de-uso-avanzados","text":"","title":"Casos de uso avanzados"},{"location":"uso_avanzado/#reinicializacion-automatica-en-pruebas","text":"AsyncDatabaseManager detecta la variable PYTEST_CURRENT_TEST y elimina autom\u00e1ticamente la base temporal antes de cada suite, evitando datos residuales entre ejecuciones. A partir de esta versi\u00f3n la comprobaci\u00f3n es perezosa: el gestor vuelve a leer PYTEST_CURRENT_TEST (y la variable SQLITEPLUS_FORCE_RESET ) cada vez que necesita crear una conexi\u00f3n. De este modo puedes activar el modo limpieza incluso si el objeto global ya estaba instanciado o si quieres forzar el borrado desde la app FastAPI (por ejemplo, antes de lanzar un lote de pruebas de integraci\u00f3n). Si la variable se activa cuando ya existe una conexi\u00f3n viva en el mismo bucle, el gestor la cierra, elimina los ficheros *.db , *.db-wal y *.db-shm y vuelve a levantar una base limpia. Usa valores como 1 , true o on para activar SQLITEPLUS_FORCE_RESET y elimina la variable cuando dejes de necesitar el borrado autom\u00e1tico.","title":"Reinicializaci\u00f3n autom\u00e1tica en pruebas"},{"location":"uso_avanzado/#conexiones-por-bucle-de-eventos","text":"Cuando se reutiliza el mismo nombre de base en distintos bucles de eventos (por ejemplo, al usar httpx.AsyncClient en paralelo), el gestor cierra y recrea la conexi\u00f3n para ese bucle, evitando errores de \"conexi\u00f3n ligada a otro loop\".","title":"Conexiones por bucle de eventos"},{"location":"uso_avanzado/#aplicar-sqlcipher-solo-si-existe-clave","text":"Si SQLITE_DB_KEY est\u00e1 vac\u00edo, la API trabaja sin cifrado. Al definir la variable se ejecuta PRAGMA key y se propagan los posibles errores de SQLCipher en los logs.","title":"Aplicar SQLCipher solo si existe clave"},{"location":"uso_avanzado/#replicacion-y-exportaciones-automatizadas","text":"El m\u00f3dulo sqliteplus.utils.replication_sync.SQLiteReplication permite: backup_database() \u2013 genera copias fechadas y duplica ficheros WAL/SHM si existen. replicate_database(<ruta>) \u2013 clona la base en otra ruta aplicando la misma clave SQLCipher. export_to_csv(<tabla>, <archivo>) \u2013 exporta columnas y filas preservando el nombre de campos. A partir de esta versi\u00f3n, al instanciar SQLiteReplication() sin argumentos se crea una copia local en ./sqliteplus/databases/database.db , exactamente igual que hace la CLI. Esto evita que los procesos automatizados modifiquen el paquete instalado y garantiza que cualquier replicaci\u00f3n o exportaci\u00f3n parta de un archivo sobre el que se puede escribir en el directorio de trabajo. Cuando el origen solicitado est\u00e1 dentro del paquete o se detecta que no es escribible, el m\u00f3dulo realiza una copia byte a byte en el directorio local (incluyendo los pares -wal / -shm ). Si la base de datos original no existe se aborta la operaci\u00f3n con un mensaje claro en lugar de crear un archivo vac\u00edo.","title":"Replicaci\u00f3n y exportaciones automatizadas"},{"location":"uso_avanzado/#actualizacion-caliente-de-usuarios","text":"sqliteplus.auth.users.get_user_service() mantiene una cach\u00e9 basada en la firma del archivo. Al modificar SQLITEPLUS_USERS_FILE se detecta el cambio autom\u00e1ticamente y se recarga la lista de usuarios sin reiniciar el proceso.","title":"Actualizaci\u00f3n caliente de usuarios"},{"location":"uso_basico/","text":"Uso b\u00e1sico 1. Configura las variables de entorno export SECRET_KEY=$(python -c \"import secrets; print(secrets.token_urlsafe(32))\") export SQLITE_DB_KEY=$(python -c \"import secrets; print(secrets.token_hex(32))\") export SQLITEPLUS_USERS_FILE=\"$(pwd)/users.json\" SQLITEPLUS_USERS_FILE solo es obligatorio para la API protegida con JWT. La CLI local puede trabajar sin ese archivo. Crea el archivo users.json con hashes bcrypt : python - <<'PY' from sqliteplus._compat import ensure_bcrypt import json, pathlib bcrypt = ensure_bcrypt() password = \"admin\" path = pathlib.Path(\"users.json\") path.write_text( json.dumps({\"admin\": bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()}) ) PY Alternativamente puedes generar hashes con el helper integrado, que delega en ensure_bcrypt() y evita tener que conocer si el backend nativo est\u00e1 disponible. Si no pasas la contrase\u00f1a como argumento, se solicitar\u00e1 de forma oculta con getpass : python -m sqliteplus.auth.users hash admin # o bien: python -m sqliteplus.auth.users hash Cuando ejecutes cualquiera de los ejemplos anteriores sin la dependencia compilada instalada, ensure_bcrypt() activar\u00e1 autom\u00e1ticamente el m\u00f3dulo sqliteplus._compat.bcrypt . Si prefieres trabajar siempre con el backend oficial instala el extra security ( pip install \"sqliteplus-enhanced[security]\" ). 2. Arranca la API uvicorn sqliteplus.main:app --reload 3. Obt\u00e9n un token JWT BASE_URL=${BASE_URL:-http://127.0.0.1:8000} curl -X POST \"${BASE_URL%/}/token\" \\ -H \"Content-Type: application/x-www-form-urlencoded\" \\ -d \"username=admin&password=admin\" Si sirves la aplicaci\u00f3n detr\u00e1s de un root_path (por ejemplo /api/sqlite ), define BASE_URL con dicho prefijo para que las rutas se resuelvan correctamente. La respuesta incluye access_token y token_type . 4. Crea una tabla en la base demo curl -X POST \"http://127.0.0.1:8000/databases/demo/create_table?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"columns\": {\"id\": \"INTEGER PRIMARY KEY\", \"msg\": \"TEXT\", \"created_at\": \"TEXT\"}}' 5. Inserta datos curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"values\": {\"msg\": \"Hola desde SQLitePlus\"}}' 6. Consulta los registros curl -X GET \"http://127.0.0.1:8000/databases/demo/fetch?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" Recibir\u00e1s todas las filas de la tabla en formato JSON. El listado aparece bajo las claves rows y data (esta \u00faltima es un alias para compatibilidad con clientes antiguos).","title":"Uso b\u00e1sico"},{"location":"uso_basico/#uso-basico","text":"","title":"Uso b\u00e1sico"},{"location":"uso_basico/#1-configura-las-variables-de-entorno","text":"export SECRET_KEY=$(python -c \"import secrets; print(secrets.token_urlsafe(32))\") export SQLITE_DB_KEY=$(python -c \"import secrets; print(secrets.token_hex(32))\") export SQLITEPLUS_USERS_FILE=\"$(pwd)/users.json\" SQLITEPLUS_USERS_FILE solo es obligatorio para la API protegida con JWT. La CLI local puede trabajar sin ese archivo. Crea el archivo users.json con hashes bcrypt : python - <<'PY' from sqliteplus._compat import ensure_bcrypt import json, pathlib bcrypt = ensure_bcrypt() password = \"admin\" path = pathlib.Path(\"users.json\") path.write_text( json.dumps({\"admin\": bcrypt.hashpw(password.encode(), bcrypt.gensalt()).decode()}) ) PY Alternativamente puedes generar hashes con el helper integrado, que delega en ensure_bcrypt() y evita tener que conocer si el backend nativo est\u00e1 disponible. Si no pasas la contrase\u00f1a como argumento, se solicitar\u00e1 de forma oculta con getpass : python -m sqliteplus.auth.users hash admin # o bien: python -m sqliteplus.auth.users hash Cuando ejecutes cualquiera de los ejemplos anteriores sin la dependencia compilada instalada, ensure_bcrypt() activar\u00e1 autom\u00e1ticamente el m\u00f3dulo sqliteplus._compat.bcrypt . Si prefieres trabajar siempre con el backend oficial instala el extra security ( pip install \"sqliteplus-enhanced[security]\" ).","title":"1. Configura las variables de entorno"},{"location":"uso_basico/#2-arranca-la-api","text":"uvicorn sqliteplus.main:app --reload","title":"2. Arranca la API"},{"location":"uso_basico/#3-obten-un-token-jwt","text":"BASE_URL=${BASE_URL:-http://127.0.0.1:8000} curl -X POST \"${BASE_URL%/}/token\" \\ -H \"Content-Type: application/x-www-form-urlencoded\" \\ -d \"username=admin&password=admin\" Si sirves la aplicaci\u00f3n detr\u00e1s de un root_path (por ejemplo /api/sqlite ), define BASE_URL con dicho prefijo para que las rutas se resuelvan correctamente. La respuesta incluye access_token y token_type .","title":"3. Obt\u00e9n un token JWT"},{"location":"uso_basico/#4-crea-una-tabla-en-la-base-demo","text":"curl -X POST \"http://127.0.0.1:8000/databases/demo/create_table?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"columns\": {\"id\": \"INTEGER PRIMARY KEY\", \"msg\": \"TEXT\", \"created_at\": \"TEXT\"}}'","title":"4. Crea una tabla en la base demo"},{"location":"uso_basico/#5-inserta-datos","text":"curl -X POST \"http://127.0.0.1:8000/databases/demo/insert?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"values\": {\"msg\": \"Hola desde SQLitePlus\"}}'","title":"5. Inserta datos"},{"location":"uso_basico/#6-consulta-los-registros","text":"curl -X GET \"http://127.0.0.1:8000/databases/demo/fetch?table_name=logs\" \\ -H \"Authorization: Bearer <TOKEN>\" Recibir\u00e1s todas las filas de la tabla en formato JSON. El listado aparece bajo las claves rows y data (esta \u00faltima es un alias para compatibilidad con clientes antiguos).","title":"6. Consulta los registros"}]}